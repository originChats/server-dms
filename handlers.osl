def handleAuth(*Connection conn, object msg) (
    string token = msg.validator.toStr()
    if token == "" (
        conn.Send(authErrorMsg("missing token"))
        return
    )
    object resp = requests.Get("https://api.rotur.dev/validate?key=originChats-dms&v=" ++ token)

    if !resp.success (
        conn.Send(authErrorMsg("failed to validate token"))
        return
    )

    object json = resp.body.toStr().JsonParse()
    if json.error != null (
        conn.Send(authErrorMsg(json.error.toStr()))
        return
    )
    if !json.valid (
        conn.Send(authErrorMsg("invalidate token"))
        return
    )
    
    string id = json.id.toStr()
    string username = json.username.toStr()
    
    lock.Lock("users")
    users[conn] = id
    lock.Unlock("users")

    userConnections[id] = conn
    conn.Set("id", id)
    conn.Set("username", username)
    conn.Set("ratelimit_timestamp", timestamp.toNum())
    conn.Set("ratelimit_count", 0)

    string path = "db/users/" ++ id ++ ".json"
    if !fs.Exists(path) (
        fs.WriteFile(path, {
            id: id,
            username: username,
            channels: []
        })
    )

    object user = getUser(id)

    conn.Send({
        cmd: "auth_success",
        val: "Authentication successful"
    })
    conn.Send({
        cmd: "ready",
        user: {
            username,
            roles: ["user"] ++ user.channels.assert(array)
        }
    })

    broadcastUserConnect(id, username, user.channels.assert(array))
)

def handleChannelsGet(*Connection conn, object msg) (
    if !requireAuth(conn) (
        conn.Send({
            cmd: "error",
            val: "Authentication required"
        })
        return
    )
    if !checkReadRequestLimit(conn) (
        conn.Send({
            cmd: "error",
            val: "Rate limit exceeded. Please slow down."
        })
        return
    )
    string id = getUserId(conn)
    object user = getUser(id)

    array formattedChannels = formatSortedChannelsForAPI(user)

    conn.Send({
        cmd: "channels_get",
        val: formattedChannels
    })
)

def populateUserRoles(array channels, string excludeId, array includeIds) array (
    array usersList = []
    array userIds = []

    for i channels.len (
        string channelId = channels[i].toStr()
        object ch = getChannel(channelId)
        if ch != null and typeof(ch.members) == "array" (
            array members = ch.members.assert(array)
            for j members.len (
                string member = members[j].toStr()

                if member == excludeId (
                    continue
                )
                
                if userIds.contains(member) (
                    continue
                )
                if includeIds != null and includeIds.len > 0 and !includeIds.contains(member) (
                    continue
                )
                object memberUser = getUser(member)
                array memberChannels = []
                if typeof(memberUser.channels) == "array" (
                    array mc = memberUser.channels.assert(array)
                    for k mc.len (
                        string mcChannelId = mc[k].toStr()
                        if channels.contains(mcChannelId) (
                            memberChannels.append(mcChannelId)
                        )
                    )
                )
                usersList.append({
                    username: memberUser.username.toStr(),
                    color: null,
                    roles: ["user"] ++ memberChannels
                })
                userIds.append(member)
            )
        )
    )
    return usersList
)

def handleUsersList(*Connection conn, object msg) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkReadRequestLimit(conn) (
        return
    )
    object user = getUser(id)

    if typeof(user.channels) != "array" (
        conn.Send({
            cmd: "users_list",
            users: []
        })
        return
    )

    array channels = user.channels.assert(array)
    array usersList = populateUserRoles(channels, id, null)

    conn.Send({
        cmd: "users_list",
        users: usersList
    })
)

def handleUsersOnline(*Connection conn, object msg) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkReadRequestLimit(conn) (
        return
    )
    object user = getUser(id)

    if typeof(user.channels) != "array" (
        conn.Send({
            cmd: "users_online",
            users: []
        })
        return
    )

    array channels = user.channels.assert(array)
    array onlineIds = []

    auto connections = server.GetConnections()
    for i connections.len (
        auto memberConn = connections[i].assert(*Connection)
        auto connId = memberConn.Get("id")
        if connId != null and connId.toStr() != "" (
            onlineIds.append(connId.toStr())
        )
    )

    array usersList = populateUserRoles(channels, id, onlineIds)
    usersList.append({
        username: user.username.toStr(),
        color: null,
        roles: ["user"] ++ user.channels.assert(array)
    })

    conn.Send({
        cmd: "users_online",
        users: usersList
    })
)

def handleMessagesGet(*Connection conn, object msg) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        conn.Send({
            cmd: "error",
            val: "Authentication required"
        })
        return
    )
    if !checkReadRequestLimit(conn) (
        conn.Send({
            cmd: "error",
            val: "Rate limit exceeded. Please slow down."
        })
        return
    )
    string channel = msg.channel.toStr()

    if channel == "cmds" (
        conn.Send({
            channel,
            cmd: "messages_get",
            messages: [{
                user: "rotur",
                content: "**Available Commands:**\n\n`dm add <username>` - Add a DM channel with another user\nExample: dm add Mist\n\n`group create <name> <user1 user2 ...>` - Create a group channel with optional members\nExample: /group create MyGroup Mist add\n\n`group add <channel_name> <username>` - Add a user to an existing group\nExample: /group add MyGroup Mist",
                timestamp,
                edited: false
            }]
        })
        return
    )

    object ch = getChannel(channel)
    if ch == null (
        conn.Send({
            cmd: "error",
            val: "Channel not found"
        })
        return
    )

    object user = getUser(id)
    if typeof(user.channels) != "array" (
        conn.Send({
            cmd: "error",
            val: "You are not a member of this channel"
        })
        return
    )

    array channels = user.channels.assert(array)
    if !channels.contains(channel) (
        conn.Send({
            cmd: "error",
            val: "You are not a member of this channel"
        })
        return
    )

    array messages = getChannelMessages(channel)
    array formattedMessages = []
    int len = messages.len
    int i = 1
    while i <= len (
        formattedMessages.append(formatMessageForAPI(messages[i].assert(object)))
        i = i + 1
    )

    conn.Send({
        channel,
        cmd: "messages_get",
        messages: formattedMessages
    })
)

def handleDMAddCommand(*Connection conn, string targetUsername) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    
    string targetId = getIdByUsername(targetUsername)
    if targetId == "" or targetId == id (
        conn.Send({
            cmd: "error",
            val: "User '" ++ targetUsername ++ "' does not exist in the database"
        })
        return
    )

    string channelId = createDMChannel(id, targetId)
    
    sendUpdatedChannelsToChannelMembers(channelId)
)

def handleGroupCreateCommand(*Connection conn, array parts) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    
    if parts.len < 4 (
        conn.Send({
            cmd: "error",
            val: "Usage: /group create <name> <user1 user2 ...>"
        })
        return
    )

    string name = parts[3].toStr()
    array members = []
    if parts.len >= 4 (
        int i = 4
        int len = parts.len
        while i <= len (
            string member = parts[i].toStr()
            members.append(member)
            i = i + 1
        )
    )

    array nonexistentUsers = []
    int memLen = members.len
    int j = 1
    while j <= memLen (
        string member = members[j].toStr()
        if !userExistsByUsername(member) (
            nonexistentUsers.append(member)
        )
        j = j + 1
    )

    if nonexistentUsers.len > 0 (
        string errorMsg = "Failed to create group: the following users do not exist in the database: "
        int errorLen = nonexistentUsers.len
        int k = 1
        while k <= errorLen (
            errorMsg = errorMsg ++ nonexistentUsers[k].toStr()
            if k < errorLen (
                errorMsg = errorMsg ++ ", "
            )
            k = k + 1
        )
        conn.Send({
            cmd: "error",
            val: errorMsg
        })
        return
    )

    string channelId = createGroupChannel(id, name, members)
    
    sendUpdatedChannelsToChannelMembers(channelId)
)

def handleGroupAddCommand(*Connection conn, array parts) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    
    if parts.len < 5 (
        conn.Send({
            cmd: "error",
            val: "Usage: /group add <channel_name> <username>"
        })
        return
    )

    string channelName = parts[3].toStr()
    string targetUsername = parts[4].toStr()

    string targetId = getIdByUsername(targetUsername)
    if targetId == "" (
        conn.Send({
            cmd: "error",
            val: "User '" ++ targetUsername ++ "' does not exist in the database"
        })
        return
    )

    object user = getUser(id)
    
    if typeof(user.channels) != "array" (
        conn.Send({
            cmd: "error",
            val: "No channels found"
        })
        return
    )

    array channels = user.channels.assert(array)
    string channelId = ""
    for i channels.len (
        string c = channels[i].toStr()
        auto channel = getChannel(c)
        if channel.type.toStr() == "group" and channel.name.toStr() == channelName (
            channelId = c
        )
    )

    if channelId == "" (
        conn.Send({
            cmd: "error",
            val: "Group '" ++ channelName ++ "' not found"
        })
        return
    )

    bool success = addUserToGroupChannel(channelId, targetId)
    if success (
        sendUpdatedChannelsToChannelMembers(channelId)
    ) else (
        conn.Send({
            cmd: "error",
            val: "Failed to add user to group (may already be a member)"
        })
    )
)

def handleProcessCommand(*Connection conn, string content, string channel) (
    if channel == "cmds" (
        return
    )

    array parts = content.split(" ")
    int len = parts.len

    if len < 2 (
        return
    )

    string cmdRoot = parts[1].toStr()
    string cmdType = ""
    if len >= 3 (
        cmdType = parts[2].toStr()
    )

    if cmdRoot != "dm" and cmdRoot != "group" (
        return
    )

    if cmdRoot == "dm" (
        if cmdType != "add" (
            return
        )
        if len < 3 (
            conn.Send({
                cmd: "error",
                val: "Usage: /dm add <username>"
            })
            return
        )
        handleDMAddCommand(conn, parts[3].toStr())
    ) else if cmdRoot == "group" (
        if cmdType == "create" (
            handleGroupCreateCommand(conn, parts)
        ) else if cmdType == "add" (
            handleGroupAddCommand(conn, parts)
        )
    )
)

def handleMessageNew(*Connection conn, object msg) (
    string channel = msg.channel.toStr()
    string content = msg.content.toStr()
    string replyToId = ""
    if typeof(msg.reply_to) == "string" (
        replyToId = msg.reply_to.toStr()
    )

    if content.startsWith("/") (
        handleProcessCommand(conn, content, channel)
        return
    )

    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )

    if channel == "cmds" (
        array parts = content.split(" ")
        string cmdType = parts[1]
        switch cmdType (
            case "dm"
                if parts.len < 3 (
                    conn.Send({
                        cmd: "error",
                        val: "Usage: dm add <username>"
                    })
                    return
                )
                handleDMAddCommand(conn, parts[3].toStr())
            case "group"
                if parts.len < 4 (
                    conn.Send({
                        cmd: "error",
                        val: "Usage: group create <name> <user1 user2 ...>"
                    })
                    return
                )
                handleGroupCreateCommand(conn, parts)
            case "group_add"
                if parts.len < 5 (
                    conn.Send({
                        cmd: "error",
                        val: "Usage: group add <channel_name> <username>"
                    })
                    return
                )
                handleGroupAddCommand(conn, parts)
        )
        return
    )

    if !verifyChannelMember(conn, id, channel) (
        return
    )

    object message = sendChannelMessage(channel, content, id, replyToId)
    if message == null (
        conn.Send({
            cmd: "error",
            val: "Failed to send message"
        })
        return
    )

    sendMessageToAllUsersInChannel(conn, channel, {
        cmd: "message_new",
        message: formatMessageForAPI(message),
        channel: channel,
        global: true
    })

    sendUpdatedChannelsToChannelMembers(channel)
)

def handleDMCreate(*Connection conn, object msg) (
    string id = getUserId(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )

    string targetUsername = msg.targetUsername.toStr()

    string targetId = getIdByUsername(targetUsername)
    if targetId == "" or targetId == id (
        conn.Send({
            cmd: "error",
            val: "User '" ++ targetUsername ++ "' does not exist in the database"
        })
        return
    )

    string channelId = createDMChannel(id, targetId)

    sendUpdatedChannelsToChannelMembers(channelId)
)

def sendMessageToAllUsersInChannel(*Connection conn, string channel, object message) (
    object ch = getChannel(channel)
    if ch != null and typeof(ch.members) == "array" (
        array members = ch.members.assert(array)
        auto connections = server.GetConnections()
        for i connections.len (
            auto memberConn = connections[i].assert(*Connection)
            auto connId = memberConn.Get("id")
            if connId == null or connId.toStr() == "" (
                continue
            )
            if !members.contains(connId.toStr()) (
                continue
            )
            memberConn.Send(message)
        )
    )
)

def getChannelMemberIds(string channelId) array (
    object ch = getChannel(channelId)
    if ch == null or typeof(ch.members) != "array" (
        return []
    )
    return ch.members.assert(array)
)

def sendUpdatedChannelsToChannelMembers(string channel) (
    array memberIds = getChannelMemberIds(channel)
    if memberIds.len == 0 (
        return
    )

    for i memberIds.len (
        string memberId = memberIds[i].toStr()
        auto memberConn = userConnections[memberId]
        if memberConn != null and typeof(memberConn) == "*Connection" (
            auto conn = memberConn.assert(*Connection)
            auto connId = conn.Get("id")
            if connId != null and connId.toStr() != "" (
                string id = connId.toStr()
                object user = getUser(id)
                if user != null (
                    array formattedChannels = formatSortedChannelsForAPI(user)
                    conn.Send({
                        cmd: "channels_get",
                        val: formattedChannels
                    })
                )
            )
        )
    )
)

def handleTyping(*Connection conn, object msg) (
    string channel = msg.channel.toStr()
    string id = getUserId(conn)
    string username = getUsername(conn)
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    if !verifyChannelMember(conn, id, channel) (
        return
    )

    sendMessageToAllUsersInChannel(conn, channel, {
        cmd: "typing",
        user: username,
        channel: channel
    })
)

def handleMessageEdit(*Connection conn, object msg) (
    string channel = msg.channel.toStr()
    string id = getUserId(conn)
    string newContent = msg.content.toStr()
    string messageId = msg.id.toStr()
    if messageId == "" (
        conn.Send({
            cmd: "error",
            val: "Missing id parameter"
        })
        return
    )
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    if !verifyChannelMember(conn, id, channel) (
        return
    )

    object message = getMessage(channel, messageId)
    if message == null (
        conn.Send({
            cmd: "error",
            val: "Message not found"
        })
        return
    )

    if message.user.toStr() != id (
        conn.Send({
            cmd: "error",
            val: "You can only edit your own messages"
        })
        return
    )

    bool success = editChannelMessage(channel, messageId, newContent, id)
    if !success (
        conn.Send({
            cmd: "error",
            val: "Failed to edit message"
        })
        return
    )

    object updatedMessage = getMessage(channel, messageId)
    sendMessageToAllUsersInChannel(conn, channel, {
        cmd: "message_edit",
        id: updatedMessage.id,
        content: newContent,
        message: formatMessageForAPI(updatedMessage),
        channel: channel,
        global: true
    })

    sendUpdatedChannelsToChannelMembers(channel)
)

def handleMessageDelete(*Connection conn, object msg) (
    string channel = msg.channel.toStr()
    string id = getUserId(conn)
    string messageId = msg.id.toStr()
    if messageId == "" (
        conn.Send({
            cmd: "error",
            val: "Missing id parameter"
        })
        return
    )
    if !requireAuth(conn) (
        return
    )
    if !checkRateLimit(conn) (
        return
    )
    if !verifyChannelMember(conn, id, channel) (
        return
    )

    object message = getMessage(channel, messageId)
    if message == null (
        conn.Send({
            cmd: "error",
            val: "Message not found"
        })
        return
    )

    if message.user.toStr() != id (
        conn.Send({
            cmd: "error",
            val: "You can only delete your own messages"
        })
        return
    )

    bool success = deleteChannelMessage(channel, messageId, id)
    if !success (
        conn.Send({
            cmd: "error",
            val: "Failed to delete message"
        })
        return
    )

    sendMessageToAllUsersInChannel(conn, channel, {
        cmd: "message_delete",
        id: messageId,
        channel: channel,
        global: true
    })

    sendUpdatedChannelsToChannelMembers(channel)
)

def getUsername(*Connection conn) string (
    auto val = conn.Get("username")
    if val == null (
        return ""
    )
    return val.toStr()
)

def getUserId(*Connection conn) string (
    auto val = conn.Get("id")
    if val == null (
        return ""
    )
    return val.toStr()
)

def isAuthenticated(*Connection conn) boolean (
    return conn.Get("id") != ""
)

def requireAuth(*Connection conn) bool (
    if !isAuthenticated(conn) (
        conn.Send(authErrorMsg("Authentication required"))
        return false
    )
    return true
)

def requireAuthWithId(*Connection conn) string (
    if !isAuthenticated(conn) (
        conn.Send(authErrorMsg("Authentication required"))
        return ""
    )
    return getUserId(conn)
)

def checkRateLimit(*Connection conn) bool (
    return checkRateLimitWithParams(conn, 60, 60000)
)

def checkReadRequestLimit(*Connection conn) bool (
    return checkRateLimitWithParams(conn, 120, 60000)
)

def checkRateLimitWithParams(*Connection conn, int maxRequests, int window) bool (
    number now = timestamp.toNum()
    number lastTime = conn.Get("ratelimit_timestamp").toNum()
    number count = conn.Get("ratelimit_count").toNum()

    if now - lastTime > window (
        conn.Set("ratelimit_timestamp", now)
        conn.Set("ratelimit_count", 0)
        return true
    )

    if count >= maxRequests (
        conn.Send({
            cmd: "error",
            val: "Rate limit exceeded. Please slow down."
        })
        return false
    )

    conn.Set("ratelimit_count", count + 1)
    return true
)

def verifyChannelMember(*Connection conn, string id, string channelId) bool (
    if channelId == "cmds" (
        return true
    )
    object user = getUser(id)
    if typeof(user.channels) != "array" (
        conn.Send({
            cmd: "error",
            val: "You are not a member of this channel"
        })
        return false
    )
    array channels = user.channels.assert(array)
    if !channels.contains(channelId) (
        conn.Send({
            cmd: "error",
            val: "You are not a member of this channel"
        })
        return false
    )
    return true
)

def broadcastUserConnect(string id, string username, array channels) (
    object connectMsg = {
        cmd: "user_connect",
        user: {
            username: username,
            roles: ["user"] ++ channels,
            color: null
        }
    }
    auto connections = server.GetConnections()
    for i connections.len (
        auto memberConn = connections[i].assert(*Connection)
        auto connId = memberConn.Get("id")
        if connId == null or connId.toStr() == "" (
            continue
        )
        if connId.toStr() == id (
            continue
        )
        object memberUser = getUser(connId.toStr())
        if typeof(memberUser.channels) == "array" (
            array memberChannels = memberUser.channels
            bool sharesChannel = false
            for j memberChannels.len (
                if channels.contains(memberChannels[j].toStr()) (
                    sharesChannel = true
                    break
                )
            )
            if sharesChannel (
                memberConn.Send(connectMsg)
            )
        )
    )
)

def broadcastUserDisconnect(string id) (
    if id == "" (
        return
    )
    string username = getUsernameById(id)
    if username == "" (
        return
    )
    object disconnectMsg = {
        cmd: "user_disconnect",
        username: username
    }
    object user = getUser(id)
    array channels = []
    if typeof(user.channels) == "array" (
        channels = user.channels
    )
    auto connections = server.GetConnections()
    for i connections.len (
        auto memberConn = connections[i].assert(*Connection)
        auto connId = memberConn.Get("id")
        if connId == null or connId.toStr() == "" (
            continue
        )
        if connId.toStr() == id (
            continue
        )
        object memberUser = getUser(connId.toStr())
        if typeof(memberUser.channels) == "array" (
            array memberChannels = memberUser.channels.assert(array)
            bool sharesChannel = false
            for j memberChannels.len (
                if channels.contains(memberChannels[j].toStr()) (
                    sharesChannel = true
                    break
                )
            )
            if sharesChannel (
                memberConn.Send(disconnectMsg)
            )
        )
    )
)